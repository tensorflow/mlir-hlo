# [RFC] Add Buffer Types

Status: In Review<br/>
Initial version: 07/29/2025<br/>
Last updated: 08/05/2025<br/>
Discussion thread: N/A

## Overview

This RFC proposes adding explicit buffer types to match the functionality of
the XLA/HLO buffer types. The XLA/HLO buffer type proposal is [here](https://docs.google.com/document/d/1v7WVJR_ozvUqjfts_EMbpzj9oJhxIgCOadC9ryzcwD0/edit?usp=drive_link&resourcekey=0-ZZaFZADBP4dJj6rQBNKGOg).

## Proposal

Change the Types section of the spec to include `BufferType` in `ValueType`:

```ebnf
ValueType ::= TensorType | QuantizedTensorType | TokenType | TupleType | BufferType
```

```ebnf
BufferType ::= 'memref' '<' Shape BufferElementType '>'
Shape ::= {DimensionSize 'x'}
DimensionSize ::= digit {digit} | '?'
```

**Buffer types** represent buffers. For example, in XLA, buffers are
multidimensional arrays with consistent storage. Similar to **tensor types**,
buffer types have a **shape** and an **element type**, where a shape represents
non-negative or unknown **dimension sizes** in the ascending order of the
corresponding **dimensions** (which are also called **axes**) numbered from `0`
to `R-1`. The number of dimensions `R` is called **rank**. For example,
`memref<2x3xf32>` is a buffer type with shape `2x3` and element type `f32`. It
has two dimensions (or, in other words, two axes) - 0th dimension and 1st
dimension - whose sizes are 2 and 3. Its rank is 2.

Buffers can be allocated using a `custom_call` to `CreateBuffer` or `Pin` and
deallocated via a `custom_call` to `Unpin`. Only `custom_call` ops can read and
write the content inside buffers. See [custom_call](#custom_call) for more
detail.

The `custom_call` op is extended to allow buffers in `inputs` and `results`:

### custom_call

#### Semantics

Encapsulates an implementation-defined operation `call_target_name` that takes
`inputs` and `called_computations` and produces `results`. `has_side_effect`,
`backend_config` and `api_version` may be used to provide additional
implementation-defined metadata.

At the moment, this operation contains a fairly disorganized collection of
metadata which reflects organic evolution of its counterpart operation in
the XLA compiler. In the future, we are planning to unify this metadata
([#741](https://github.com/openxla/stablehlo/issues/741)).

#### Inputs

| Label | Name                     | Type                                                       |
|-------|--------------------------|------------------------------------------------------------|
| (I1)  | `inputs`                 | variadic number of values                                  |
| (I2)  | `call_target_name`       | constant of type `string`                                  |
| (I3)  | `has_side_effect`        | constant of type `i1`                                      |
| (I4)  | `backend_config`         | constant of type `string` or attribute dictionary          |
| (I5)  | `api_version`            | constant of type `si32`                                    |
| (I6)  | `called_computations`    | variadic number of constants of type `string`              |
| (I7)  | `output_operand_aliases` | specify the aliasing parts in the outputs and operands     |

#### Outputs

| Name      | Type                     |
|-----------|--------------------------|
| `results` | variadic number of values|

### (XLA GPU Support) Special custom_call targets

There are three special `call_target_name` related to `buffer` types:
`CreateBuffer` creates an uninitialized `buffer`, `Pin` creates an initialized
`buffer` and `Unpin` deallocates a `buffer` and returns the content of the
`buffer`.

```mlir
%uninitialized_buffer = "stablehlo.custom_call"() {
  call_target_name = "CreateBuffer",
  api_version = 4 : i32,
} : () -> memref<4xf64>

%initialized_buffer = "stablehlo.custom_call"(%init_value) {
  call_target_name = "Pin",
  api_version = 4 : i32,
} : (tensor<4xf64>) -> memref<4xf64>

%dealloc_buffer = "stablehlo.custom_call"(%initialized_buffer) {
  call_target_name = "Unpin",
  api_version = 4 : i32,
} : (memref<4xf64>) -> tensor<4xf64>

```

### Alias

Some custom_call ops may require a part in the outputs and a part in the
operands to share the same memory. This can be expressed via
`output_operand_aliases`. An alias pair representation consists a list of output
 tuple indices representing the output part, and an operand_index along with a
 list of operand tuple indices representing the operand part. The list of output
  or operand tuple indices is empty if the corresponding type is not a `tuple`
  type, and can be arbitrarily long for an arbitrarily nested tuple type. This
  is similar to [the XLA alias representation](https://www.tensorflow.org/xla/aliasing).

The output part and the input part in an alias pair must have the same type. For
custom_call ops that aren't call to `CreateBuffer`, `Pin` and `Unpin`, a
`buffer` operand can appear in at most one pair of alias, and a `buffer` output
must appear in one pair of alias.

#### Examples

```mlir
%results = "stablehlo.custom_call"(%input0) {
  call_target_name = "foo",
  has_side_effect = false,
  backend_config = {bar = 42 : i32},
  api_version = 4 : i32,
  called_computations = [@foo]
} : (tensor<f64>) -> tensor<f64>

%updated_buffer = "stablehlo.custom_call"(%buffer) {
  call_target_name = "Update",
  api_version = 4 : i32,
  output_operand_aliases = [
    #stablehlo.output_operand_alias<output_tuple_indices = [],
      operand_index = 0,
      operand_tuple_indices = []>]
} : (memref<4xf64>) -> memref<4xf64>

```

The `get_tuple_element` op is extended to allow buffers:

### get_tuple_element

> Note: Per [StableHLO v1.0 Cleanup #2283](https://github.com/openxla/stablehlo/pull/2283),
> this op is being explored for deprecation as it appears to be unused by both
> frameworks and compilers. As such, it has limited compatibility guarantees
> (6 months).

#### Semantics

Extracts element at `index` position of the `operand` tuple and produces a
`result`. More formally, `result = operand[index]`.

#### Inputs

| Label | Name      | Type                    | Constraints |
|-------|-----------|-------------------------|-------------|
| (I1)  | `operand` | tuple                   | (C1), (C2)  |
| (I2)  | `index`   | constant of type `si32` | (C1), (C2)  |

#### Outputs

| Name     | Typ                    | Constraints |
|----------|------------------------|-------------|
| `result` | any value              | (C2)        |

#### Constraints

* (C1) `0 <= index < size(operand)`.
* (C2) `type(result) = tuple_element_types(operand)[index]`.

#### Examples

```mlir
// %operand: ([1.0, 2.0], (3))
%result = "stablehlo.get_tuple_element"(%operand) <{index = 0 : i32}> : (tuple<tensor<2xf64>, tuple<tensor<i64>>>) -> tensor<2xf64>
// %result: [1.0, 2.0]
```

&nbsp;[More Examples](https://github.com/openxla/stablehlo/tree/main/stablehlo/tests/interpret/tuple_and_get_tuple_element.mlir)

The `tuple` op is extended to accept buffers:

### tuple

> Note: Per [StableHLO v1.0 Cleanup #2283](https://github.com/openxla/stablehlo/pull/2283),
> this op is being explored for deprecation as it appears to be unused by both
> frameworks and compilers. As such, it has limited compatibility guarantees
> (6 months).

#### Semantics

Produces a `result` tuple from values `val`.

#### Inputs

| Label | Name  | Type                      | Constraints |
|-------|-------|---------------------------|-------------|
| (I1)  | `val` | variadic number of values | (C1)        |

#### Outputs

| Name     | Type  | Constraints |
|----------|-------|-------------|
| `result` | tuple | (C1)        |

#### Constraints

* (C1) `result` has type `tuple<E0, ..., EN-1>` where `Ei = type(val[i])`.

#### Examples

```mlir
// %val0: memref[1.0, 2.0]
// %val1: (3)
%result = "stablehlo.tuple"(%val0, %val1) : (memref<2xf32>, tuple<tensor<i32>>) -> tuple<memref<2xf32>, tuple<tensor<i32>>>
// %result: (memref[1.0, 2.0], (3))
```

&nbsp;[More Examples](https://github.com/openxla/stablehlo/tree/main/stablehlo/tests/interpret/tuple_and_get_tuple_element.mlir)

The `while` op is extended to allow buffers in `operands` and `results`:

### while

#### Semantics

Produces the output from executing `body` function 0 or more times while the
`cond` function outputs `true`. More formally, the semantics can be expressed
using Python syntax as follows:

```python
internal_state = operand
while cond(*internal_state):
  internal_state = body(*internal_state)
results = internal_state
```

The behavior of an infinite loop is TBD
([#383](https://github.com/openxla/stablehlo/issues/383)).

#### Inputs

| Label | Name      | Type                                    | Constraints |
|-------|-----------|-----------------------------------------|-------------|
| (I1)  | `operand` | variadic number of values               | (C1-C3)     |
| (I2)  | `cond`    | function                                | (C1)        |
| (I3)  | `body`    | function                                | (C2)        |

#### Outputs

| Name      | Type                                            | Constraints |
|-----------|-------------------------------------------------|-------------|
| `results` | variadic number of values                       | (C3)        |
