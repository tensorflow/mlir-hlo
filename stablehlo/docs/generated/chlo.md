<!-- Autogenerated by mlir-tblgen; don't manually edit -->

# 'chlo' Dialect

_Client HLO Ops_

This dialect contains ops that align closely with the API surface area
of the XlaBuilder C++ API, where such ops have semantics that go beyond
what exists in the lower level dialects (such as `stablehlo`). Essentially,
whenever the client library uses syntactic sugar or composition
of multiple ops for an API call, this dialect tries to model the API call
and provide conversion patterns to fully materialize into lower level
dialects.

[TOC]

## Operations

### `chlo._asin_acos_kernel` (chlo::AsinAcosKernelOp)

_AsinAcosKernel operator_

Syntax:

```
operation ::= `chlo._asin_acos_kernel` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `AsinAcosKernel(operand)` element-wise.

```
If
  w = _asin_acos_kernel(z)
  w' = _asin_acos_kernel(I * z)
Then
  asin(z) = complex(atan2(z.real, w.real), sign(z.imag) * w.imag)
  acos(z) = complex(atan2(w.real, z.real), -sign(z.imag) * w.imag)
  asinh(z) = complex(sign(z.real) * w'.imag, atan2(z.imag, w'.real))
  acosh(z) = complex(w.imag, sign(z.imag) * atan2(w.real, z.real))
```

This op is used as an intermediate value in decompositions and
should never be constructed directly by frameworks or consumed by
backends.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of complex type with 32/64-bit float elements values |



### `chlo.acos` (chlo::AcosOp)

_Acos operator_

Syntax:

```
operation ::= `chlo.acos` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Acos(operand)` element-wise.

$$
\acos(x) = 2 * \atan(\sqrt(1 - x^2) / (1 + x)) if x != -1
         = pi                                  if x == -1
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.acosh` (chlo::AcoshOp)

_Acosh operation_

Syntax:

```
operation ::= `chlo.acosh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Acosh(operand)` element-wise.

$$
\acosh(x) = log(x + sqrt(x^2 - 1))      if x >= -1
\acosh(x) = nan                         if x < -1
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.asin` (chlo::AsinOp)

_Asin operator_

Syntax:

```
operation ::= `chlo.asin` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Asin(operand)` element-wise.

$$
\asin(x) = 2 * atan(x / (1 + sqrt(1 - x^2)))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.asinh` (chlo::AsinhOp)

_Asinh operation_

Syntax:

```
operation ::= `chlo.asinh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Asinh(operand)` element-wise.

$$
\asinh(x) = log(x + sqrt(x^2 + 1))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.atan` (chlo::AtanOp)

_Atan operator_

Syntax:

```
operation ::= `chlo.atan` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Atan(operand)` element-wise.

$$
\atan(x) = \atan2(x, 1)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.atanh` (chlo::AtanhOp)

_Atanh operator_

Syntax:

```
operation ::= `chlo.atanh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Atanh(operand)` element-wise.

$$
\atanh(x) = 0.5 * log((1 + x) / (1 - x)) if abs(x) <= 1
          = nan                          otherwise
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.bessel_i1e` (chlo::BesselI1eOp)

_Bessel function of order 1_

Syntax:

```
operation ::= `chlo.bessel_i1e` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `bessel_i1e(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.broadcast_add` (chlo::BroadcastAddOp)

_Addition operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_add` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs + rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_and` (chlo::BroadcastAndOp)

_Logical and operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_and` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_and(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |
| `rhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_atan2` (chlo::BroadcastAtan2Op)

_Atan2 operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_atan2` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `atan2(lhs/rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_compare` (chlo::BroadcastCompareOp)

_Compare operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_compare` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Compares `lhs` and `rhs` elementwise according to `comparison_direction`
and `compare_type`. If unspecified, `compare_type` is FLOAT for float element
types, SIGNED for signed element types and UNSIGNED for unsigned element
types.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_comparison_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
<tr><td><code>comparison_direction</code></td><td>::mlir::chlo::ComparisonDirectionAttr</td><td>Which comparison operation to perform.</td></tr>
<tr><td><code>compare_type</code></td><td>::mlir::chlo::ComparisonTypeAttr</td><td>Which comparison type to use.</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of bool values |



### `chlo.broadcast_complex` (chlo::BroadcastComplexOp)

_Complex operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_complex` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Performs element-wise conversion of a pair of real and imaginary values to
a complex value.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of complex type with 32/64-bit float elements values |



### `chlo.broadcast_divide` (chlo::BroadcastDivOp)

_Division operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_divide` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs / rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_maximum` (chlo::BroadcastMaxOp)

_Maximum operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_maximum` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `max(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_minimum` (chlo::BroadcastMinOp)

_Minimum operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_minimum` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `min(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_multiply` (chlo::BroadcastMulOp)

_Multiplication operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_multiply` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs * rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_next_after` (chlo::BroadcastNextAfterOp)

_Std::nextafter operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_next_after` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns the next representable value of `lhs` in the direction of `rhs`,
element-wise. It can also return a subnormal number.

Equivalent to the C++ std::nextafter function.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_or` (chlo::BroadcastOrOp)

_Logical or operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_or` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_or(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |
| `rhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_polygamma` (chlo::BroadcastPolygammaOp)

_Polygamma function (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_polygamma` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `Polygamma(operand, operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_power` (chlo::BroadcastPowOp)

_Power operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_power` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs ^ rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_remainder` (chlo::BroadcastRemOp)

_Remainder operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_remainder` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs % rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_select` (chlo::BroadcastSelectOp)

_Select operator (with optional numpy-style broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_select` $pred `,` $on_true `,` $on_false attr-dict `:`
              `(` type($pred) `,` type($on_true) `,` type($on_false) `)` `->` type(results)
```

Constructs an output array from elements of two input arrays, based on the
values of a predicate array.

See https://www.tensorflow.org/xla/operation_semantics#select

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `pred` | ranked tensor of bool values |
| `on_true` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `on_false` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_shift_left` (chlo::BroadcastShiftLeftOp)

_Shift left operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_left` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs << rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_shift_right_arithmetic` (chlo::BroadcastShiftRightArithmeticOp)

_Shift right arithmetic operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_right_arithmetic` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs >> rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_shift_right_logical` (chlo::BroadcastShiftRightLogicalOp)

_Shift right logical operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_right_logical` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs >> rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_subtract` (chlo::BroadcastSubOp)

_Subtraction operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_subtract` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs - rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_xor` (chlo::BroadcastXorOp)

_Logical xor operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_xor` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_xor(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |
| `rhs` | tensor of bool or 2/4/8/16/32/64-bit integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.broadcast_zeta` (chlo::BroadcastZetaOp)

_Hurwitz zeta function_

Syntax:

```
operation ::= `chlo.broadcast_zeta` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `Zeta(operand, operand)` element-wise.

$$
\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.conj` (chlo::ConjOp)

_Conj operator_

Syntax:

```
operation ::= `chlo.conj` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Conj(operand)` element-wise.

$$
\conj(x) = (\real(x), \neg(\imag(x)))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.constant` (chlo::ConstantOp)

_Constant operator_

Syntax:

```
operation ::= `chlo.constant` attr-dict $value
```

Represents a constant value.

Traits: `AlwaysSpeculatableImplTrait`, `ConstantLike`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | statically shaped tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized values |



### `chlo.constant_like` (chlo::ConstantLikeOp)

_Constant like operator_

Returns a splat constant of the same shape as the operand.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.cosh` (chlo::CoshOp)

_Cosh operator_

Syntax:

```
operation ::= `chlo.cosh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Cosh(operand)` element-wise.

$$
\cosh(x) = (e^x + e^-x) / 2
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.digamma` (chlo::DigammaOp)

_Digamma function_

Syntax:

```
operation ::= `chlo.digamma` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Digamma(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.erf` (chlo::ErfOp)

_Erfc operator_

Syntax:

```
operation ::= `chlo.erf` $operand attr-dict `:` type($operand) `->` type($result)
```

Computes the Gauss error function of `x` element-wise.

erf(x) = erf_impl(x)            if |x| < 1
       = 1 - erfc_impl(x)       otherwise

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.erf_inv` (chlo::ErfInvOp)

_Inverse Erf_

Syntax:

```
operation ::= `chlo.erf_inv` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `ErfInv(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.erfc` (chlo::ErfcOp)

_Erfc operator_

Syntax:

```
operation ::= `chlo.erfc` $operand attr-dict `:` type($operand) `->` type($result)
```

Computes an approximation of the error function complement (1 - erf(x)).

erfc(x) = erfc_impl(x)           if |x| > 1
        = 1 - erf_impl(x)        otherwise

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.is_inf` (chlo::IsInfOp)

_IsInf predicate_

Syntax:

```
operation ::= `chlo.is_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is +/-inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool values |



### `chlo.is_neg_inf` (chlo::IsNegInfOp)

_IsNegInf predicate_

Syntax:

```
operation ::= `chlo.is_neg_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is -inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool values |



### `chlo.is_pos_inf` (chlo::IsPosInfOp)

_IsPosInf predicate_

Syntax:

```
operation ::= `chlo.is_pos_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is +inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool values |



### `chlo.lgamma` (chlo::LgammaOp)

_Lgamma function_

Syntax:

```
operation ::= `chlo.lgamma` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Lgamma(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.next_after` (chlo::NextAfterOp)

_Std::nextafter operator_

Syntax:

```
operation ::= `chlo.next_after` $x `,` $y attr-dict `:` type($x) `,` type($y) `->` type(results)
```

Returns the next representable value of `x` in the direction of `y`,
element-wise. It can also return a subnormal number.

Equivalent to the C++ std::nextafter function.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `x` | tensor of 4/6/8/16/32/64-bit float values |
| `y` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.polygamma` (chlo::PolygammaOp)

_Polygamma function_

Syntax:

```
operation ::= `chlo.polygamma` $n `,` $x attr-dict `:` type($n) `,` type($x) `->` type(results)
```

Returns `Polygamma(operand, operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `n` | tensor of 4/6/8/16/32/64-bit float values |
| `x` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



### `chlo.ragged_dot` (chlo::RaggedDotOp)

_Computes a matmul over a single ragged dimension_

This operation takes three tensor args---lhs, rhs, and group_sizes---and
a "ragged_dot_dimension_numbers" attribute. Like dot_general, the lhs and
rhs are allowed arbitrary batch and contracting dimensions. Additionally,
the lhs is required to have one ragged dimension, and the rhs may have at
most one group dimension. The op has three modes, depending on the kind of
the lhs ragged dimension.

In mode 1, the shape-signature is `[b,m,k], [g,b,k,n], [b,g] -> [b,m,n]`.
Here the ragged dimension is an lhs non-contracting dimension (`m`). The
dimensions `b` and `k` represent batch and contracting dimensions
respectively. The rhs is required to have a group dimension (`g`).

In mode 2, the shape-signature is `[b,m,k], [b,k,n], [b,g] -> [g,b,m,n]`.
Here the ragged dimension is an lhs/rhs contracting dimension (`k`).

In mode 3, the shape-signature is `[b,m,k], [b,k,n], [g] -> [b,m,n]`. Here
the ragged dimension is an lhs/rhs batch dimension (`b`).


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ragged_dot_dimension_numbers</code></td><td>::mlir::chlo::RaggedDotDimensionNumbersAttr</td><td>Attribute that models the dimension information for ragged dot.</td></tr>
<tr><td><code>precision_config</code></td><td>::mlir::ArrayAttr</td><td>Precision Config attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `rhs` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `group_sizes` | ranked tensor of 2/4/8/16/32/64-bit integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.sinh` (chlo::SinhOp)

_Sinh operation_

Syntax:

```
operation ::= `chlo.sinh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Sinh(operand)` element-wise.

$$
\sinh(x) = (e^x - e^-x) / 2                     if |x| < 1
         = e^(x + log(1/2)) - e^(-x + log(1/2)) otherwise.
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.square` (chlo::SquareOp)

_Square operation_

Syntax:

```
operation ::= `chlo.square` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Square(operand)` element-wise.

$$
\square(x) = complex((x.real - x.imag) * (x.real + x.imag), x.real * x.imag * 2) if x is a complex number
           = x * x                                                               otherwise
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.tan` (chlo::TanOp)

_Tan operation_

Syntax:

```
operation ::= `chlo.tan` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Tan(operand)` element-wise.

$$
\tan(x) = \sin(x) / \cos(x)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float or complex type with 32/64-bit float elements values |



### `chlo.top_k` (chlo::TopKOp)

_Finds values and indices of the `k` largest elements for the last dimension_

Syntax:

```
operation ::= `chlo.top_k` `(`$operand `,` `k` `=` $k`)` attr-dict `:`
              type($operand) `->` `(`type($values)`,` type($indices)`)`
```

If the input is a vector (rank-1), finds the `k` largest entries in the
vector and outputs their values and indices as vectors.  Thus `values[j]` is
the `j`-th largest entry in `input`, and its index is `indices[j]`.

For matrices (resp. higher rank input), computes the top `k` entries in each
row (resp. vector along the last dimension).  Thus,

```
values.shape = indices.shape = input.shape[:-1] + [k]
```

If two elements are equal, the lower-index element appears first.

Traits: `AlwaysSpeculatableImplTrait`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `values` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |
| `indices` | tensor of 4/6/8/16/32/64-bit float or bool or 2/4/8/16/32/64-bit integer or complex type with 32/64-bit float elements or per-tensor integer quantized or per-axis integer quantized values |



### `chlo.zeta` (chlo::ZetaOp)

_Hurwitz zeta function_

Syntax:

```
operation ::= `chlo.zeta` $x `,` $q attr-dict `:` type($x) `,` type($q) `->` type(results)
```

Returns `Zeta(operand, operand)` element-wise.

$$
\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `x` | tensor of 4/6/8/16/32/64-bit float values |
| `q` | tensor of 4/6/8/16/32/64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of 4/6/8/16/32/64-bit float values |



## Attributes

### ComparisonDirectionAttr

_Which comparison operation to perform._

Syntax:

```
#chlo.comparison_direction<
  ::mlir::chlo::ComparisonDirection   # value
>
```

Enum cases:
* EQ (`EQ`)
* NE (`NE`)
* GE (`GE`)
* GT (`GT`)
* LE (`LE`)
* LT (`LT`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::ComparisonDirection` | an enum of type ComparisonDirection |

### ComparisonTypeAttr

_Which comparison type to use._

Syntax:

```
#chlo.comparison_type<
  ::mlir::chlo::ComparisonType   # value
>
```

Enum cases:
* NOTYPE (`NOTYPE`)
* FLOAT (`FLOAT`)
* TOTALORDER (`TOTALORDER`)
* SIGNED (`SIGNED`)
* UNSIGNED (`UNSIGNED`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::ComparisonType` | an enum of type ComparisonType |

### PrecisionAttr

_XLA precision for an operand. Has backend specific meaning._

Syntax:

```
#chlo.precision<
  ::mlir::chlo::Precision   # value
>
```

Enum cases:
* DEFAULT (`DEFAULT`)
* HIGH (`HIGH`)
* HIGHEST (`HIGHEST`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::Precision` | an enum of type Precision |

### RaggedDotDimensionNumbersAttr

_Attribute that models the dimension information for ragged dot._

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| lhsBatchingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsBatchingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| lhsContractingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsContractingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| lhsRaggedDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsGroupDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |

## Enums

### ComparisonDirection

_Which comparison operation to perform._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| EQ | `0` | EQ |
| NE | `1` | NE |
| GE | `2` | GE |
| GT | `3` | GT |
| LE | `4` | LE |
| LT | `5` | LT |

### ComparisonType

_Which comparison type to use._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| NOTYPE | `0` | NOTYPE |
| FLOAT | `1` | FLOAT |
| TOTALORDER | `2` | TOTALORDER |
| SIGNED | `3` | SIGNED |
| UNSIGNED | `4` | UNSIGNED |

### Precision

_XLA precision for an operand. Has backend specific meaning._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| DEFAULT | `0` | DEFAULT |
| HIGH | `1` | HIGH |
| HIGHEST | `2` | HIGHEST |
